/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package com.ebay.sojourner.ubd.common.model;

import com.ebay.sojourner.ubd.common.util.Constants;
import lombok.Data;
import lombok.Getter;

import java.io.Serializable;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Data
public class UbiEvent implements Serializable {
  private String guid;
  private String sessionId;
  private Integer seqNum;
  private Long sessionStartDt;
  private Long sojDataDt;
  private Integer clickId;
  private Integer siteId;
  private Integer version;
  private Integer pageId;
  private String pageName;
  private Long refererHash;
  private Long eventTimestamp;
  private String urlQueryString;
  private ClientData clientData;
  private String cookies;
  private String applicationPayload;
  private String webServer;
  private String referrer;
  private String userId;
  private Long itemId;
  private String flags;
  private Integer rdt;
  private Integer regu;
  private String sqr;
  private Integer staticPageType;
  private Integer reservedForFuture;
  private String eventAttr;
  private Long currentImprId;
  private Long sourceImprId;
  private Integer cobrand;
  private Integer iframe;
  private String agentInfo;
  private String forwardedFor;
  private String clientIP;
  private Integer bitVal;
  private Integer appId;
  private Long oldSessionSkey;
  private Integer hashCode;
  private Integer partialValidPage;
  private long sessionStartTime;
  private long sessionEndTime;
  @Getter private long eventCnt;
  private Map<String, Object> counters;
  public void updateSessionId() {
    int charPos = Constants.HEX_DIGITS.length;
    int mask = (1 << 4) - 1;
    long decimal = sessionStartTime;
    char[] out = new char[Constants.HEX_DIGITS.length];

    for (int i = 0; i < out.length; i++) {
      out[i] = '0';
    }

    do {
      out[--charPos] = Constants.HEX_DIGITS[(int) (decimal & mask)];
      decimal = decimal >>> 4;
    } while (decimal != 0);

    this.sessionId = guid + new String(out, 0, out.length);
  }
  public void eventCountIncrementByOne() {
    eventCnt++;
  }
  public boolean isNewSession() {
    return Constants.NO_SESSION_ID.equals(sessionId);
  }

  public boolean hasSessionEndTime() {
    return Constants.NO_TIMESTAMP != sessionEndTime;
  }

  public Object get(String key) {
    if (counters == null) {
      synchronized (this) {
        if (counters == null) {
          counters = new ConcurrentHashMap<String, Object>();
        }
      }
    }

    return counters.get(key);
  }

  public void put(String key, Object value) {
    if (counters == null) {
      synchronized (this) {
        if (counters == null) {
          counters = new ConcurrentHashMap<String, Object>();
        }
      }
    }

    counters.put(key, value);
  }
}
